#ifndef A_TOKEN_TYPES_HPP
#define A_TOKEN_TYPES_HPP

#include "EnumBase.hpp"
#include <unordered_map>

namespace A
{

  enum class TokenClass{
    NO_CLASS,
    MARKUP_TOKEN,
    RVALUE_TOKEN,
    SCRIPT_TOKEN,
  };
  
  enum class NestLevel : std::uint64_t{
    
    UNNESTED = BIT(0),
    MARKUP = BIT(1),
    MARKUP_MAIN_COMPONENT = BIT(2),
    MARKUP_SUB_COMPONENT = BIT(3),
    MARKUP_ID_COMPONENT = BIT(4),
    MARKUP_ID_COMPONENT_KEY = BIT(5),
    COMPONENT = MARKUP_MAIN_COMPONENT | MARKUP_SUB_COMPONENT | MARKUP_ID_COMPONENT,
    RVALUE = BIT(6),
    RVALUE_SUB_EXPRESSION = BIT(7),
    RVALUE_LIST = BIT(8),
    RVALUE_TUPLE = BIT(9),
    RVALUE_DICTIONARY = BIT(10),
    RVALUE_LAMBDA_DEFINITION_PARAMETER_LIST = BIT(11),
    RVALUE_LAMBDA_DEFINITION_PRE_PARAMETER_LIST = BIT(12),
    RVALUE_LAMBDA_BODY = BIT(13),
    RVALUE_FUNCTION_CALL_PARAMETER_LIST = BIT(14),
    RVALUE_CONTAINER_INDEX = BIT(15),
    RVALUE_TEXT_DOUBLE_QUOTED = BIT(16),
    RVALUE_TEXT_SINGLE_QUOTED = BIT(17),
    RVALUE_CONDITION = BIT(18),

    SCRIPT = BIT(19),
    SCRIPT_DICTIONARY_KEY_TYPE = BIT(20),
    SCRIPT_DICTIONARY_VALUE_TYPE = BIT(21),
    SCRIPT_TUPLE_ELEMENTS_TYPES = BIT(22),


    SCRIPT_FUNCTION_DECLARATION = BIT(23),
    SCRIPT_FUNCTION_PARAMETER_TYPES = BIT(24),
    SCRIPT_FUNCTION_PARAMETER_LIST = BIT(25),

    SCRIPT_FUNCTION_BODY = BIT(26),

    SCRIPT_IF_CONDITION = BIT(27),
    SCRIPT_IF_BODY = BIT(28),
    SCRIPT_WHILE_CONDITION = BIT(29),
    SCRIPT_WHILE_BODY = BIT(30),
    SCRIPT_ELSEIF_BODY = BIT(31),
    SCRIPT_ELSEIF_CONDITION = BIT(32),

    SCRIPT_ELSE_BODY = BIT(33),

    SCRIPT_CONDITION = SCRIPT_IF_CONDITION | SCRIPT_WHILE_CONDITION | SCRIPT_ELSEIF_CONDITION,
    SCRIPT_CONDITION_BODY = SCRIPT_IF_BODY | SCRIPT_WHILE_BODY | SCRIPT_ELSEIF_BODY | SCRIPT_ELSE_BODY,

    SCRIPT_NAME_DECLARATION = BIT(34),

    SCRIPT_COMMAND = UNNESTED | SCRIPT | SCRIPT_CONDITION_BODY | SCRIPT_FUNCTION_BODY,
  };
  ENUM_FLAG_BIN_OPERATOR(NestLevel, &)
  ENUM_FLAG_BIN_OPERATOR(NestLevel, |)
  ENUM_FLAG_UN_OPERATOR(NestLevel, ~)
  extern std::unordered_map<NestLevel, std::string> NEST_LEVELS_STRINGS;
  
  enum class MarkupTokenType : std::uint64_t{
    NO_TOKEN = 0,
    UNDEFINED = BIT(0),
    MAIN_COMPONENT_OPENING = BIT(1),
    MAIN_COMPONENT_OPENING_NAME = BIT(2),
    MAIN_COMPONENT_OPENING_NAME_CLOSING = BIT(3),
    MAIN_COMPONENT_CLOSING = BIT(4),
    MAIN_COMPONENT_CLOSING_SLASH = BIT(5),
    MAIN_COMPONENT_CLOSING_NAME = BIT(6),
    MAIN_COMPONENT_CLOSING_NAME_CLOSING = BIT(7),
    ID_COMPONENT_OPENING = BIT(8),
    ID_COMPONENT_ID_NAME = BIT(9),
    ID_COMPONENT_ID_EQUAL = BIT(10),
    ID_COMPONENT_ID_CLOSING = BIT(11),
    ID_COMPONENT_CLOSING = BIT(12),
    ID_COMPONENT_CLOSING_SLASH = BIT(13),
    ID_COMPONENT_CLOSING_ID_NAME = BIT(14),
    ID_COMPONENT_CLOSING_ID_NAME_CLOSING = BIT(15),
    SUB_COMPONENT_NAME = BIT(16),
    SUB_COMPONENT_BRACKET = BIT(17),
    SUB_COMPONENT_CLOSING = BIT(18),
    STANDALONE_SWITCH = BIT(19),
    SWITCH_NAME = BIT(20),
    SWITCH_COLON = BIT(21),
    SWITCH_VALUE_START = BIT(22),
    TAG_NAME = BIT(23), 
    TAG_EQUAL = BIT(24),
    PREPROCESSOR_COMMAND_BEGIN = BIT(25),
    COMMENT_BEGIN = BIT(26),
    COMMENT_END = BIT(27),
    MULTILINE_COMMENT_OPENING = BIT(28),
    MULTILINE_COMMENT_BODY = BIT(29),
    MULTILINE_COMMENT_CLOSING = BIT(30),
  };
  ENUM_FLAG_BIN_OPERATOR(MarkupTokenType, &)
  ENUM_FLAG_BIN_OPERATOR(MarkupTokenType, |)
  ENUM_FLAG_UN_OPERATOR(MarkupTokenType, ~)
  extern std::unordered_map<MarkupTokenType, std::string> MARKUP_TOKEN_TYPES_STRINGS;
  
  enum class ScriptTokenType : std::uint64_t{

    NO_TOKEN = 0,
    DECLARATION_LET = BIT(0),
    QUALIFIER = BIT(1),
    TYPE_NAME = BIT(2),
    TYPE_DELIMETER = BIT(3),
    VARIABLE_NAME = BIT(4),
    DEFINITION_EQUAL = BIT(5),
    ALIAS_ARROW = BIT(6),
    LIST_ELEMENTS_TYPE_OPENING = BIT(7),
    LIST_ELEMENTS_TYPE_CLOSING = BIT(8),
    DICTIONARY_ELEMENTS_TYPE_OPENING = BIT(9),
    DICTIONARY_TYPE_ARROW = BIT(10),
    DICTIONARY_ELEMENTS_TYPE_CLOSING = BIT(11),

    TUPLE_ELEMENTS_TYPES_OPENING = BIT(12),
    TUPLE_ELEMENTS_TYPES_COMMA = BIT(13),
    TUPLE_ELEMENTS_TYPES_CLOSING = BIT(14),

    FUNCTION_PARAMETERS_VALUE_TYPE_OPENING = BIT(15),
    FUNCTION_PARAMETERS_TYPES_COMMA = BIT(16),
    FUNCTION_VALUE_TYPE_COLON = BIT(17),
    FUNCTION_PARAMETERS_VALUE_TYPE_CLOSING = BIT(18),

    FUNCTION_DEFINITION_OPENING = BIT(19),
    FUNCTION_NAME = BIT(20),

    FUNCTION_DECLARATION_PARAMETER_LIST_OPENING = BIT(21),
    FUNCTION_DECLARATION_PARAMETER_LIST_CLOSING = BIT(22),
    FUNCTION_PARAMETER_NAME = BIT(23),
    FUNCTION_VALUE_TYPE = BIT(24),
    FUNCTION_DEFINITION_CLOSING = BIT(25),
    FUNCTION_DEFINITION_COLON = BIT(26),
    FUNCTION_PARAMETERS_COMMA = BIT(27),

    IF_CONDITION_OPENING = BIT(28),
    IF_CONDITION_CLOSING = BIT(29),

    ELSEIF_CONDITION_OPENING = BIT(30),
    ELSEIF_CONDITION_CLOSING = BIT(31),

    WHILE_CONDITION_OPENING = BIT(32),
    WHILE_CONDITION_CLOSING = BIT(33),

    IF_CONDITION_BODY_OPENING = BIT(34),
    IF_CONDITION_BODY_CLOSING = BIT(35),

    CONDITION_OPENING = IF_CONDITION_OPENING | ELSEIF_CONDITION_OPENING | WHILE_CONDITION_OPENING,
      
    ELSEIF_CONDITION_BODY_OPENING = BIT(36),
    ELSEIF_CONDITION_BODY_CLOSING = BIT(37),

    ELSE_CONDITION_BODY_OPENING = BIT(38),
    ELSE_CONDITION_BODY_CLOSING = BIT(39),

    WHILE_CONDITION_BODY_OPENING = BIT(40),
    WHILE_CONDITION_BODY_CLOSING = BIT(41),
      
    BLOCK_END = BIT(42),

    LVALUE_NAME = BIT(43),
  };
  ENUM_FLAG_BIN_OPERATOR(ScriptTokenType, &)
  ENUM_FLAG_BIN_OPERATOR(ScriptTokenType, |)
  ENUM_FLAG_UN_OPERATOR(ScriptTokenType, ~)
  extern std::unordered_map<ScriptTokenType, std::string> SCRIPT_TOKEN_TYPES_STRINGS;
  
  enum class RValueTokenType : std::uint64_t{
    NO_TOKEN = 0,
    NUMBER = BIT(0),
    CONSTANT = BIT(1),
    IDENTIFIER = BIT(2),
    INFIX_OPERATOR = BIT(3),
    PREFIX_OPERATOR = BIT(4),
    SUB_EXPRESSION_OPENING = BIT(5),
    SUB_EXPRESSION_CLOSING = BIT(6),
    LIST_OPENING = BIT(7),
    LIST_CLOSING = BIT(8),
    TUPLE_OPENING = BIT(9),
    TUPLE_CLOSING = BIT(10),
    DICTIONARY_OPENING = BIT(11),
    DICTIONARY_CLOSING = BIT(12),
    DICTIONARY_KEY = BIT(13),
    DICTIONARY_KEY_EQUAL = BIT(14),
    CONTAINER_INDEX_OPENING = BIT(15),
    CONTAINER_INDEX_CLOSING = BIT(16),
    LAMBDA_OPENING = BIT(17),
    LAMBDA_PARAMETER_LIST_OPENING = BIT(18),
    LAMBDA_PARAMETER_LIST_CLOSING = BIT(19),
    LAMBDA_BODY_OPENING = BIT(20),
    LAMBDA_BODY_CLOSING = BIT(21),
    LAMBDA_CLOSING = BIT(22),
    MEMBER_OPERATOR = BIT(23),
    TEXT_OPENING = BIT(24),
    TEXT_CONTENT = BIT(25),
    TEXT_CLOSING = BIT(26),
    FUNCTION_CALL_PARAMETER_LIST_OPENING = BIT(27),
    FUNCTION_CALL_PARAMETER_LIST_CLOSING = BIT(28),
    FUNCTION_CALL_PARAMETERS_COMMA = BIT(29),
    VALUE = NUMBER | TEXT_CLOSING | CONSTANT | IDENTIFIER | LIST_CLOSING | TUPLE_CLOSING | DICTIONARY_CLOSING | LAMBDA_CLOSING | FUNCTION_CALL_PARAMETER_LIST_CLOSING,
  };
  ENUM_FLAG_BIN_OPERATOR(RValueTokenType, &)
  ENUM_FLAG_BIN_OPERATOR(RValueTokenType, |)
  ENUM_FLAG_UN_OPERATOR(RValueTokenType, ~)
  extern std::unordered_map<RValueTokenType, std::string> RVALUE_TOKEN_TYPES_STRINGS;
  
}
  
#endif // A_TOKEN_TYPES_HPP
